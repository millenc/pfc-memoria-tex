\chapter{Implementación en MATLAB}
En este capítulo se incluye el código fuente de la implementación en MATLAB de los métodos estudiados en este proyecto.

\section{General}
En esta sección se incluyen algunas funciones de propósito general que han sido implementadas en el desarrollo de este proyecto.

\subsection{T-normas y operadores de agregación}
MATLAB dispone de una colección importante de funciones predefinidas para calcular t-normas y operadores de agregación. En este proyecto se han utilizado las siguientes:

\begin{itemize}
\item Media aritmética: \lstinline|mean()|.
\item Máximo: \lstinline|max()|.
\item Producto: \lstinline|prod()|.
\item Mínimo: \lstinline|min()|.
\item Media geométrica: \lstinline|geomean()|.
\item Media armónica: \lstinline|harmmean()|.
\end{itemize}

Además se han implementado sendas funciones para calcular las t-normas del seno y de Einstein:

\lstinputlisting[label=lst:sinmean, caption=T-norma del seno (\lstinline|functions/sinmean.m|),inputencoding=cp1252]{./matlab/functions/sinmean.m}

\lstinputlisting[label=lst:einsteinmean, caption=T-norma de Einstein (\lstinline|functions/einsteinmean.m|),inputencoding=cp1252]{./matlab/functions/einsteinmean.m}

Como se puede ver en la función \lstinline|einsteinmean()| se ha utilizado una función anónima (\lstinline|@(x)(1-x)|), que es una funcionalidad muy útil de MATLAB, inspirada en los lenguajes funcionales, que permite declarar funciones \emph{lambda} o \emph{anónimas} (sin nombre) y utilizarlas como argumentos de otras funciones (en este caso de \lstinline|arrayfun()|, que aplica dicha función anónima a todos los elementos de un vector). Esta característica del lenguaje de MATLAB se utilizará también a la hora de definir índices de solapamiento.

\section{Detección de incendios forestales}
\subsection{Variables lingüísticas}
Como se ha definido en \ref{def:formal-lang-variable}, una variable lingüística es una variable que puede tomar conjuntos difusos como valores. Así mismo, un conjunto difuso viene definido por su función de pertenencia. Por tanto, se debe definir una función para cada valor de cada variable lingüística utilizada. 

Generalmente, en MATLAB, cada función se define en un fichero separado que únicamente contiene el código de dicha función. En este caso y dado que se utilizan 5 variables lingüísticas para los antecedentes con 3 valores posibles cada una y una variable de salida para el consecuente con 5 valores posibles, habría que crear 20 ficheros para definir estas funciones. Aunque es perfectamente posible y válido hacerlo de esta manera, resulta tedioso manejar tantos ficheros. 

Una solución adecuada al problema es definir cada variable lingüística en un fichero en el que se implementan las funciones de pertenencia de sus posibles valores. Para ello se puede crear una clase para cada variable lingüística y definir la función de pertenencia de cada valor como un método estático de la misma. Esta forma de definir las variables lingüísticas tiene la ventaja de que todo el código asociado a la variable está en un mismo fichero. Además la forma de utilizar las funciones resulta muy cómoda y expresiva.

Por ejemplo, para la variable lingüística $\chi_1$ = \emph{Temperatura} se ha definido la clase \lstinline|temp| en el fichero \lstinline|lang_variables/temp.m|. Esta clase tiene los siguientes métodos estáticos:
\begin{itemize}
\item \lstinline|get_x()| : Devuelve el universo de referencia para la variable (en este caso el vector $[0,100]$).
\item \lstinline|low(t)| : Función de pertenencia para el valor ``Bajo''.
\item \lstinline|medium(t)| : Función de pertenencia para el valor ``Medio''.
\item \lstinline|high(t)| : Función de pertenencia para el valor ``Alto''.
\end{itemize}

De esta forma, para obtener el grado de pertenencia de un valor \lstinline|t| al conjunto \emph{``Temperatura Media''} basta con hacer:

\begin{lstlisting}
v = temp.medium(t);
\end{lstlisting}

Además es posible obtener un puntero a estas funciones utilizando el operador \lstinline|@|:

\begin{lstlisting}
fh = @temp.medium;
v = fh(t);
\end{lstlisting}

La variable \lstinline|fh| es un puntero a la función \lstinline|temp.medium()| y puede utilizarse de la misma forma que ésta (línea 2). Además la variable \lstinline|fh| se puede utilizar de forma similar a otros tipos de variables, es decir, se pueden crear vectores de punteros de funciones, pasarlos como parámetros a otras funciones etc. Esta propiedad se utilizará de forma intensiva a la hora de implementar los métodos estudiados en este proyecto y el conjunto de reglas.

A continuación se incluyen las definiciones de las variables lingüísticas utilizadas en la aplicación práctica de detección de incendios forestales:

\lstinputlisting[caption=$\chi_1$ - Temperatura (\lstinline|lang_variables/temp.m|),inputencoding=cp1252]{./matlab/lang_variables/temp.m}

\lstinputlisting[caption=$\chi_2$ - Humo (\lstinline|lang_variables/smoke.m|), inputencoding=cp1252]{./matlab/lang_variables/smoke.m}

\lstinputlisting[caption=$\chi_3$ - Luz (\lstinline|lang_variables/llight.m|),inputencoding=cp1252]{./matlab/lang_variables/llight.m}

\lstinputlisting[caption=$\chi_4$ - Humedad (\lstinline|lang_variables/humidity.m|),inputencoding=cp1252]{./matlab/lang_variables/humidity.m}

\lstinputlisting[caption=$\chi_5$ - Distancia (\lstinline|lang_variables/distance.m|),inputencoding=cp1252]{./matlab/lang_variables/distance.m}

\lstinputlisting[caption=$y$ - Riesgo (\lstinline|lang_variables/threat.m|),inputencoding=cp1252]{./matlab/lang_variables/threat.m}

\subsection{Conjunto de reglas}

El conjunto de reglas se ha definido en la función \lstinline|fire_detection_rules()| (\lstinline|fire_detection_rules.m|), de forma que sea sencillo obtener y utilizar este conjunto en otros scripts y funciones. Esta función devuelve un vector de estructuras donde cada una tiene los siguientes campos:
\begin{itemize}
\item \lstinline|R(i).n|: Nº de regla.
\item \lstinline|R(i).A|: Vector con las funciones de pertenencia de los valores (punteros a funciones) de cada uno de los antecedentes de la regla.
\item \lstinline|R(i).B|: Puntero a función de pertenencia del valor del consecuente.
\end{itemize}

Por ejemplo para definir un conjunto de reglas con una única regla tal que:
\begin{multline}
\text{IF \emph{Temperatura} es ``Baja'' AND }  \text{ \emph{Humo} es ``Alto'' AND } \text{ \emph{Luz} es ``Baja''} \\
  \text{AND \emph{Humedad} es ``Alta'' AND }  \text{ \emph{Distancia} es ``Media'' THEN }  \text{ \emph{Riesgo} es ``Bajo'' }
\end{multline}
hay que construir una estructura de la siguiente forma:

\begin{lstlisting}
R(1).n = 1;
R(1).A = {@temp.low, @smoke.high, @llight.low, @humidity.high, @distance.medium};
R(1).B = @threat.low;
\end{lstlisting}

Este tipo de estructura tiene la ventaja de que es sencilla de implementar y de entender. Sin embargo, para conjuntos de reglas grandes (como es el caso) resulta tedioso tener que indicar el índice para cada regla y repetir una y otra vez el nombre del conjunto (\lstinline|R|) o de los campos. 

Por esta razón se ha optado por una forma de definir el conjunto de reglas más concisa y clara. El conjunto de reglas se define como una matriz, en la que cada fila corresponde a una regla y cada columna es un puntero a la función de pertenencia del valor de la variable lingüística que ocupa esa posición. Las primeras $n-1$ columnas de cada fila corresponden a los antecedentes de la regla, y la última al consecuente.

En la función  \lstinline|fire_detection_rules| (código \ref{matlab_fire_detection_rules}) se define el conjunto de reglas en la matriz \lstinline|rules| (líneas 2-335) de esta forma. Dado que el resto de funciones implementadas esperan un conjunto de reglas definido como un vector de estructuras, se transforma esta matriz en dicho vector en las líneas 340-344. De esta forma, el conjunto de reglas es muy sencillo de leer y modificar y se asemeja mucho a la tabla \ref{tab:fire-detection-rule-set}.

\lstset{linewidth=18cm}
\lstinputlisting[label=matlab_fire_detection_rules, caption=Conjunto de reglas (\lstinline|fire_detection_rules.m|) ,inputencoding=cp1252]{./matlab/fire_detection_rules.m}